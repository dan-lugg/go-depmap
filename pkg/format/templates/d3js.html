<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Go Dependency Graph - WebCola Canvas Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/webcola@3.4.0/WebCola/cola.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1e1e1e;
            color: #fff;
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #graphCanvas {
            display: block;
            cursor: grab;
        }

        #graphCanvas:active {
            cursor: grabbing;
        }

        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
            max-width: 300px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        #controls h3 {
            margin: 0 0 15px 0;
            font-size: 16px;
            border-bottom: 1px solid #444;
            padding-bottom: 8px;
        }

        #controls label {
            display: block;
            margin: 8px 0;
            font-size: 12px;
        }

        #controls input[type="checkbox"] {
            margin-right: 8px;
        }

        #controls button {
            width: 100%;
            margin-top: 10px;
            padding: 8px;
            background-color: #0078d4;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        #controls button:hover {
            background-color: #006cbd;
        }

        #info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.9);
            padding: 12px;
            border-radius: 8px;
            font-size: 12px;
            max-width: 400px;
            z-index: 100;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        #legend {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        #legend h4 {
            margin: 0 0 10px 0;
            font-size: 14px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
            font-size: 12px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 8px;
            border: 2px solid #fff;
        }

        .tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.95);
            color: #fff;
            padding: 12px;
            border-radius: 6px;
            pointer-events: none;
            font-size: 12px;
            z-index: 1000;
            max-width: 350px;
            word-wrap: break-word;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            border: 1px solid #444;
            display: none;
        }

        .tooltip strong {
            color: #00d488;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="graphCanvas"></canvas>

        <div id="controls">
            <h3>‚öôÔ∏è Controls</h3>
            <label>
                <input type="checkbox" id="showLabels" checked> Show Node Labels
            </label>
            <label>
                <input type="checkbox" id="showGroups" checked> Show Group Boundaries
            </label>
            <button id="resetBtn">Reset Layout</button>
        </div>

        <div id="legend">
            <h4>üìä Legend</h4>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #FF9800;"></div>
                <span>Functions</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #2196F3;"></div>
                <span>Methods</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #4CAF50;"></div>
                <span>Types</span>
            </div>
        </div>

        <div id="info">
            <strong>Go Dependency Graph (Canvas)</strong><br>
            Nodes: <span id="nodeCount">0</span> | Links: <span id="linkCount">0</span> | Groups: <span id="groupCount">0</span><br>
            <small>üí° Drag canvas ‚Ä¢ Zoom with wheel ‚Ä¢ Click for details</small>
        </div>
    </div>
    <div class="tooltip" id="tooltip"></div>

    <script>
        // Embedded data - will be injected by Go template
        const data = {{.Data}};

        console.log("Loaded data:", data);
        console.log("Nodes:", data.nodes.length, "Links:", data.links.length, "Groups:", (data.groups || []).length);

        // Canvas setup
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');
        const width = window.innerWidth;
        const height = window.innerHeight;

        canvas.width = width;
        canvas.height = height;

        // Color mapping for node types
        const colorMap = {
            1: '#FF9800', // Functions - orange
            2: '#2196F3', // Methods - blue
            3: '#4CAF50'  // Types - green
        };

        // UI state
        let showLabels = true;
        let showGroups = true;
        let transform = d3.zoomIdentity;
        let hoveredNode = null;
        let selectedNode = null;

        // Update info display
        document.getElementById("nodeCount").textContent = data.nodes.length;
        document.getElementById("linkCount").textContent = data.links.length;
        document.getElementById("groupCount").textContent = (data.groups || []).length;

        // Tooltip
        const tooltip = document.getElementById("tooltip");

        // Create node lookup and prepare data
        const nodeById = new Map(data.nodes.map((n, i) => [n.id, i]));

        // Prepare links with indices
        const links = data.links.map(l => ({
            source: nodeById.get(l.source),
            target: nodeById.get(l.target),
            value: l.value || 1
        }));

        // Initialize WebCola layout
        const colaLayout = new cola.Layout()
            .size([width, height])
            .nodes(data.nodes)
            .links(links)
            .avoidOverlaps(data.nodes.length < 1000) // Disable for large graphs
            .handleDisconnected(true)
            .convergenceThreshold(1e-3)
            .linkDistance(300)
            .symmetricDiffLinkLengths(15);

        // Add groups if present
        if (data.groups && data.groups.length > 0) {
            colaLayout.groups(data.groups);
        }

        // Run layout computation
        let layoutRunning = true;
        let tickCount = 0;
        const maxTicks = data.nodes.length < 500 ? 200 : 100; // Fewer ticks for large graphs

        colaLayout.start(50, 100, 200);

        // Build spatial index (quadtree) for efficient node lookup
        let quadtree = null;

        function buildQuadtree() {
            quadtree = d3.quadtree()
                .x(d => d.x)
                .y(d => d.y)
                .addAll(data.nodes);
        }

        // Calculate zoom level for LOD rendering
        function getZoomLevel() {
            const k = transform.k;
            if (k < 0.5) return 0;      // Far out - groups only
            if (k < 1.5) return 1;      // Medium - nodes only
            return 2;                    // Close up - full detail
        }

        // Check if point is in viewport (culling)
        function inViewport(x, y, margin = 50) {
            const tx = transform.applyX(x);
            const ty = transform.applyY(y);
            return tx > -margin && tx < width + margin &&
                   ty > -margin && ty < height + margin;
        }

        // Render function
        function render() {
            ctx.save();
            ctx.clearRect(0, 0, width, height);

            // Apply transform
            ctx.translate(transform.x, transform.y);
            ctx.scale(transform.k, transform.k);

            const zoomLevel = getZoomLevel();

            // Draw groups (if enabled and zoom level allows)
            if (showGroups && data.groups && data.groups.length > 0) {
                data.groups.forEach(g => {
                    if (!g.bounds) return;

                    // Check if group is in viewport
                    const gx = g.bounds.x;
                    const gy = g.bounds.y;
                    const gw = g.bounds.width();
                    const gh = g.bounds.height();

                    if (!inViewport(gx + gw/2, gy + gh/2, Math.max(gw, gh))) return;

                    ctx.save();

                    // Draw group background
                    ctx.beginPath();
                    ctx.roundRect(gx, gy, gw, gh, 8);

                    if (g.level === 'package') {
                        ctx.fillStyle = 'rgba(0, 120, 212, 0.1)';
                        ctx.strokeStyle = '#0078d4';
                    } else {
                        ctx.fillStyle = 'rgba(0, 212, 136, 0.1)';
                        ctx.strokeStyle = '#00d488';
                    }

                    ctx.lineWidth = 2 / transform.k;
                    ctx.fill();
                    ctx.stroke();

                    // Draw group label (if zoomed in enough)
                    if (zoomLevel >= 1) {
                        ctx.fillStyle = g.level === 'package' ? '#0078d4' : '#00d488';
                        ctx.font = `bold ${13 / transform.k}px 'Segoe UI', sans-serif`;
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'top';

                        // Add text shadow for readability
                        ctx.shadowColor = '#000';
                        ctx.shadowBlur = 3 / transform.k;
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 0;

                        const label = g.level === 'package' ? g.label : g.label.split('/').pop();
                        ctx.fillText(label, gx + 10, gy + 10);

                        ctx.shadowColor = 'transparent';
                    }

                    ctx.restore();
                });
            }

            // Draw links (only at zoom level 2)
            if (zoomLevel >= 2) {
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(153, 153, 153, 0.6)';
                ctx.lineWidth = 1.5 / transform.k;

                links.forEach(l => {
                    const source = data.nodes[l.source];
                    const target = data.nodes[l.target];

                    if (!source || !target) return;
                    if (!inViewport(source.x, source.y) && !inViewport(target.x, target.y)) return;

                    ctx.moveTo(source.x, source.y);
                    ctx.lineTo(target.x, target.y);
                });

                ctx.stroke();

                // Draw arrowheads
                ctx.fillStyle = '#999';
                links.forEach(l => {
                    const source = data.nodes[l.source];
                    const target = data.nodes[l.target];

                    if (!source || !target) return;
                    if (!inViewport(target.x, target.y)) return;

                    const dx = target.x - source.x;
                    const dy = target.y - source.y;
                    const len = Math.sqrt(dx * dx + dy * dy);
                    if (len === 0) return;

                    const ratio = (len - 10) / len;
                    const arrowX = source.x + dx * ratio;
                    const arrowY = source.y + dy * ratio;
                    const angle = Math.atan2(dy, dx);

                    ctx.save();
                    ctx.translate(arrowX, arrowY);
                    ctx.rotate(angle);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(-6 / transform.k, -3 / transform.k);
                    ctx.lineTo(-6 / transform.k, 3 / transform.k);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                });
            }

            // Draw nodes
            if (zoomLevel >= 1) {
                data.nodes.forEach(node => {
                    if (!inViewport(node.x, node.y)) return;

                    ctx.beginPath();
                    const radius = zoomLevel >= 2 ? 10 / transform.k : 5 / transform.k;
                    ctx.arc(node.x, node.y, radius, 0, 2 * Math.PI);

                    ctx.fillStyle = colorMap[node.group] || '#999';
                    ctx.fill();

                    // Highlight hovered node
                    if (hoveredNode === node) {
                        ctx.strokeStyle = '#ffa500';
                        ctx.lineWidth = 3 / transform.k;
                    } else {
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 1.5 / transform.k;
                    }
                    ctx.stroke();
                });
            }

            // Draw labels (only at full zoom)
            if (showLabels && zoomLevel >= 2) {
                ctx.fillStyle = '#ccc';
                ctx.font = `${11 / transform.k}px 'Segoe UI', sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';

                data.nodes.forEach(node => {
                    if (!inViewport(node.x, node.y)) return;
                    ctx.fillText(node.name, node.x, node.y + 15 / transform.k);
                });
            }

            ctx.restore();
        }

        // Layout tick handler
        colaLayout.on("tick", () => {
            tickCount++;

            // Update less frequently for large graphs
            if (data.nodes.length > 1000 && tickCount % 5 !== 0) return;

            render();

            // Stop after max ticks and rebuild quadtree
            if (tickCount >= maxTicks) {
                layoutRunning = false;
                buildQuadtree();
                colaLayout.stop();
            }
        });

        // Initial quadtree build
        buildQuadtree();

        // Zoom behavior
        const zoom = d3.zoom()
            .scaleExtent([0.1, 10])
            .on("zoom", (event) => {
                transform = event.transform;
                render();
            });

        d3.select(canvas).call(zoom);

        // Mouse interaction
        function getCanvasCoordinates(event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            // Transform to graph coordinates
            return transform.invert([x, y]);
        }

        function findNodeAt(x, y, radius = 15) {
            if (!quadtree) return null;

            let closest = null;
            let closestDist = radius;

            quadtree.visit((node, x1, y1, x2, y2) => {
                if (!node.length) {
                    do {
                        const d = node.data;
                        const dx = d.x - x;
                        const dy = d.y - y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < closestDist) {
                            closestDist = dist;
                            closest = d;
                        }

                        node = node.next;
                    } while (node);
                }

                return x1 > x + radius || x2 < x - radius ||
                       y1 > y + radius || y2 < y - radius;
            });

            return closest;
        }

        // Mouse move handler
        canvas.addEventListener('mousemove', (event) => {
            const [x, y] = getCanvasCoordinates(event);
            const node = findNodeAt(x, y);

            if (node !== hoveredNode) {
                hoveredNode = node;
                render();

                if (node) {
                    tooltip.style.display = 'block';
                    tooltip.innerHTML = `<strong>${node.name}</strong><br>` +
                        `Kind: ${node.kind}<br>` +
                        `Package: ${node.package}<br>` +
                        `File: ${node.file}:${node.line}`;
                    tooltip.style.left = (event.pageX + 10) + 'px';
                    tooltip.style.top = (event.pageY + 10) + 'px';
                } else {
                    tooltip.style.display = 'none';
                }
            } else if (node) {
                tooltip.style.left = (event.pageX + 10) + 'px';
                tooltip.style.top = (event.pageY + 10) + 'px';
            }
        });

        // Mouse leave handler
        canvas.addEventListener('mouseleave', () => {
            hoveredNode = null;
            tooltip.style.display = 'none';
            render();
        });

        // Click handler
        canvas.addEventListener('click', (event) => {
            const [x, y] = getCanvasCoordinates(event);
            const node = findNodeAt(x, y);

            if (node) {
                alert(`Name: ${node.name}\nKind: ${node.kind}\nPackage: ${node.package}\nFile: ${node.file}:${node.line}`);
            }
        });

        // Controls
        document.getElementById("showLabels").addEventListener("change", (e) => {
            showLabels = e.target.checked;
            render();
        });

        document.getElementById("showGroups").addEventListener("change", (e) => {
            showGroups = e.target.checked;
            render();
        });

        document.getElementById("resetBtn").addEventListener("click", () => {
            // Reset zoom
            d3.select(canvas).call(zoom.transform, d3.zoomIdentity);

            // Restart layout
            layoutRunning = true;
            tickCount = 0;
            colaLayout.start(50, 100, 200);
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            render();
        });

        // Initial render
        render();
    </script>
</body>
</html>

